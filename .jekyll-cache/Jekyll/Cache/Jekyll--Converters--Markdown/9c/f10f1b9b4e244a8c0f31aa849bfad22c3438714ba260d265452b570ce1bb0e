I"<<p>ECC 2 was a 200 point challenge on PicoCTF 2017.</p>

<p>We are given the following handout:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Elliptic Curve: y^2 = x^3 + A*x + B mod M
M = 93556643250795678718734474880013829509320385402690660619699653921022012489089
A = 66001598144012865876674115570268990806314506711104521036747533612798434904785
B = *You can figure this out with the point below :)*

P = (56027910981442853390816693056740903416379421186644480759538594137486160388926, 65533262933617146434438829354623658858649726233622196512439589744498050226926)
n = *SECRET*
n*P = (61124499720410964164289905006830679547191538609778446060514645905829507254103, 2595146854028317060979753545310334521407008629091560515441729386088057610440)

n &lt; 400000000000000000000000000000

Find n.
</code></pre></div></div>

<p>Our first step will be to solve for \(b\) via rearranging the elliptic curve equation:</p>

\[y^2 = x^3 + ax + b\bmod n\]

\[b = y^2 - x^3 - ax\bmod n\]

<p>In Sage, this is done via substituting the \(x\) and \(y\) values as shown:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: x, y = P[0], P[1]
sage: b = (y^2 - x^3 - a*x) % N  #The ^ operator is exponentiation instead of XOR in Sage.
sage: print(b)
25255205054024371783896605039267101837972419055969636393425590261926131199030
</code></pre></div></div>

<p>Solving for \(b\), we obtain 25255205054024371783896605039267101837972419055969636393425590261926131199030.</p>

<p>We now have all the necessary parameters for the elliptic curve.  Thus, our next step is to define the curve over a finite field of integers modulo \(M\), and define the points \(P\) and \(Q\) to be on the curve:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F = FiniteField(M)
E = EllipticCurve(F,[A,B])
P = E.point(P)
Q = E.point(Q)
</code></pre></div></div>

<p>Essentially, this challenge requires us to solve the Elliptic Curve Discrete Logarithm Problem (ECDLP): compute the scalar \(n\) given the base point \(P\) and the product point \(Q\) where \(Q = nP\).  There are a few known attacks against ECDLP, including the:</p>
<ol>
  <li>MOV attack (involves finding linearly independent points and calculating Weil pairing to reduce ECDLP to over finite field instead of group of points on elliptic curve)</li>
  <li>Pohlig-Hellman (reduces discrete logarithm calculations to prime subgroups of the order of P and uses Chinese Remainder Theorem to solve system of congruences for discrete logarithm of the whole order )</li>
</ol>

<p>We can rule out the MOV attack, since it is infeasible given the size of the elliptic curve order. However, factoring the order of our elliptic curve \(E\) reveals many small prime factors, indicating that Pohlig-Hellman could be feasible:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: factor(E.order())
2^2 * 3 * 5 * 7 * 137 * 593 * 24337 * 25589 * 3637793 * 5733569 * 106831998530025000830453 * 1975901744727669147699767  
</code></pre></div></div>

<p>The goal of Pohlig-Hellman and the mathematics leading to it is as follows:</p>

<p>We are attempting to recreate a system of congruences to solve for the value of \(l\) (referred to as \(n\) in this problem):</p>

\[l \equiv l_1\pmod{p_1^{e_1}}\]

\[l \equiv l_2\pmod{p_2^{e_2}}\]

\[\ldots\]

\[l \equiv l_i\pmod{p_i^{e_i}}\]

<p>where \(l\) denotes the discrete logarithm for the order of \(P\), \(l_i\) denotes discrete logarithm calculations for each of the smaller prime orders (factors) \(p\) of \(P\), and \(e_i\) denotes the exponent of \(p\).</p>

<p>First, define an integer \(x\) such that \(x = p_1^{e_1}p_2^{e_2}...p_{r}^{e_r}\)  (in other words, \(x\) is equivalent to the order of \(P\)).</p>

<p>\(l_i\) can be written in the form:</p>

<p>\(l_i = z_0 + z_1\,p + z_2\,p_2 + ... + z_{e−1}p-1^{e-1}\\\)
where \(z \in [0,\,p-1]\).</p>

<p>We then define the points \(P_i = \frac{x}{p_i}P\), and \(Q_i = \frac{x}{p_i}Q\).</p>

<p>Since we know that the order of \(P_i\) is \(p_i\), we can rewrite the equation as \(Q_i = lP_i = z_iP_i\), we can now solve for every \(z_0...z_{e-1}\) by finding a value for \(z_i\) such that \(Q_i = z_i*P_i\).</p>

<p>This is comparable to brute force in that if the value of \(p\) is small enough, it is feasible to try all the values of \(z\) in range of \(e\) until a value which satisfies the equation above is found.</p>

<p>In Sage, this can be done as follows:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sage</span><span class="p">:</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">593</span><span class="p">,</span> <span class="mi">24337</span><span class="p">,</span> <span class="mi">25589</span><span class="p">,</span> <span class="mi">3637793</span><span class="p">,</span> <span class="mi">5733569</span><span class="p">,</span> <span class="mi">106831998530025000830453</span><span class="p">,</span> <span class="mi">1975901744727669147699767</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">dlogs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">sage</span><span class="p">:</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
          <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">order</span><span class="p">())</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span>
          <span class="n">dlog</span> <span class="o">=</span> <span class="n">discrete_log</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">t</span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="n">operation</span><span class="o">=</span><span class="s">"+"</span><span class="p">)</span>
          <span class="n">dlogs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dlog</span><span class="p">]</span>
          <span class="k">print</span><span class="p">(</span><span class="s">"factor: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span><span class="o">+</span><span class="s">", Discrete Log: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dlog</span><span class="p">))</span> <span class="c1">#calculates discrete logarithm for each prime order
</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">137</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">129</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">593</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">224</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">24337</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">5729</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">25589</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">13993</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">3637793</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1730599</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">5733569</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">4590572</span>

</code></pre></div></div>
<p>You will notice that Sage hangs while computing the discrete logarithms for last 2 prime factors.  However, we don’t need to know them, since in the problem statement, \(l\) was defined to be less than 400000000000000000000000000000.  Multiplying every prime order save for the last 2 returns a boundary of 443208349730265573969192476820, meaning that \(l\) fits within the bound!</p>

<p>Our final step is just to solve for \(l\) via CRT:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: l = crt(dlogs.primes[:-2])
152977126447386808276536247114
</code></pre></div></div>
<p>which returns the value for \(l\)!</p>

<p>Just to check the validity of \(l\), we perform a quick boolean comparison;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: l * P == Q
True
</code></pre></div></div>

<p>Thus, our value of \(l\) is indeed correct!</p>

<h3 id="flag">Flag</h3>

<p>152977126447386808276536247114</p>

<p>Note: due to random problem generation, your value may be different.</p>

<h3 id="full-code">Full code</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="mi">93556643250795678718734474880013829509320385402690660619699653921022012489089</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">66001598144012865876674115570268990806314506711104521036747533612798434904785</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">25255205054024371783896605039267101837972419055969636393425590261926131199030</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">56027910981442853390816693056740903416379421186644480759538594137486160388926</span><span class="p">,</span> <span class="mi">65533262933617146434438829354623658858649726233622196512439589744498050226926</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">61124499720410964164289905006830679547191538609778446060514645905829507254103</span><span class="p">,</span> <span class="mi">2595146854028317060979753545310334521407008629091560515441729386088057610440</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">FiniteField</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">E</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">E</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">factors</span><span class="p">,</span> <span class="n">exponents</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">factor</span><span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">order</span><span class="p">()))</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">exponents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">))][:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="n">dlogs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">order</span><span class="p">())</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span>
    <span class="n">dlog</span> <span class="o">=</span> <span class="n">discrete_log</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">t</span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="n">operation</span><span class="o">=</span><span class="s">"+"</span><span class="p">)</span>
    <span class="n">dlogs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dlog</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"factor: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span><span class="o">+</span><span class="s">", Discrete Log: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dlog</span><span class="p">))</span> <span class="c1">#calculates discrete logarithm for each prime order
</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">crt</span><span class="p">(</span><span class="n">dlogs</span><span class="p">,</span><span class="n">primes</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="resources">Resources</h3>

<p>http://wstein.org/edu/2010/414/projects/novotney.pdf
https://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Sommerseth+Hoeiland.pdf</p>
:ET