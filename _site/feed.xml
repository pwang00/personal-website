<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/about/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/about/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-07-10T15:49:09-04:00</updated><id>http://localhost:4000/about/feed.xml</id><title type="html">blank</title><subtitle>My website where I talk about security
</subtitle><entry><title type="html">Happy (242) - Tokyo Westerns Qualifiers</title><link href="http://localhost:4000/about/blog/2019/happy/" rel="alternate" type="text/html" title="Happy (242) - Tokyo Westerns Qualifiers" /><published>2019-09-06T11:12:00-04:00</published><updated>2019-09-06T11:12:00-04:00</updated><id>http://localhost:4000/about/blog/2019/happy</id><content type="html" xml:base="http://localhost:4000/about/blog/2019/happy/"><![CDATA[<p>Happy was a 242 point crypto challenge on the 2019 Tokyo Westerns Qualifiers.</p>

<h2 id="problem-description">Problem Description</h2>

<p>No, we’Re not SAd. We are Happy!</p>

<h2 id="solution">Solution</h2>

<p>The problem description makes it pretty clear that this challenge is RSA.  Indeed, we are given 3 files of importance: happy (.rb), pub.key, and flag.enc.  We open happy.rb and find the definition of a custom defined Key class, which we figure out to be an implementation of multi-prime RSA (N = pq^k) (as shown below):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="no">Key</span><span class="p">.</span><span class="nf">new</span><span class="p">({</span>
    <span class="ss">n: </span><span class="nb">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">**</span> <span class="n">k</span><span class="p">,</span>
    <span class="ss">e: </span><span class="n">e</span><span class="p">,</span>
    <span class="ss">p: </span><span class="nb">p</span><span class="p">,</span>
    <span class="ss">q: </span><span class="n">q</span> <span class="o">**</span> <span class="n">k</span><span class="p">,</span>
    <span class="ss">d1: </span><span class="n">d1</span><span class="p">,</span>
    <span class="ss">d2: </span><span class="n">d2</span><span class="p">,</span>
    <span class="ss">cf: </span><span class="n">cf</span><span class="p">,</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Additionally, we note that the following lines are important:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def self.import(str)
    Key.new(Marshal.load(str))
</code></pre></div></div>

<p>So we can safely deduce here that the pub.key file is a serialized public key that is deserialized and parsed by the key class.  Deserializing the pub.key file yields the following parameters:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):001:0&gt; Marshal.load(File.binread("pub.key"))                                                  
=&gt; {:n=&gt;5452318773620154613572502669913080727339917760196646730652258556145398937256752632887555812737783373177353194432136071770417979324393263857781686277601413222025718171529583036919918011865659343346014570936822522629937049429335236497295742667600448744568785484756006127827416640477334307947919462834229613581880109765730148235236895292544500644206990455843770003104212381715712438639535055758354549980537386992998458659247267900481624843632733660905364361623292713318244751154245275273626636275353542053068704371642619745495065026372136566314951936609049754720223393857083115230045986813313700617859091898623345607326632849260775745046701800076472162843326078037832455202509171395600120638911, :e=&gt;65537, :cf=&gt;25895436290109491245101531425889639027975222438101136560069483392652360882638128551753089068088836092997653443539010850513513345731351755050869585867372758989503310550889044437562615852831901962404615732967948739458458871809980240507942550191679140865230350818204637158480970417486015745968144497190368319745738055768539323638032585508830680271618024843807412695197298088154193030964621282487334463994562290990124211491040392961841681386221639304429670174693151}
</code></pre></div></div>

<p>Interesting–normally, an RSA public key would contain only (N, e).  The <code class="language-plaintext highlighter-rouge">cf</code> parameter certainly doesn’t seem to match any known implementation of RSA, so we assume for now that it’s an arbitrary parameter.</p>

<p>Going back to the code, we find that <code class="language-plaintext highlighter-rouge">cf = p.pow(q ** (k - 1) * (q - 1) - 1, q ** k)</code>.  Simplifying yields <code class="language-plaintext highlighter-rouge">cf = p^(φ(q^2) - 1) mod q^2</code>, and through Euler’s theorem, <code class="language-plaintext highlighter-rouge">cf = p^-1 mod q^2</code>.  In its current form, <code class="language-plaintext highlighter-rouge">cf</code> isn’t super useful since we only have information of <code class="language-plaintext highlighter-rouge">p^-1 mod q^2</code>, but we can use this to our advantage by multiplying both sides of the equation to arrive at <code class="language-plaintext highlighter-rouge">cf * p = 1 mod q^2</code>, which translates to <code class="language-plaintext highlighter-rouge">cf * p - 1 = kq^2</code>, and multiply this again by <code class="language-plaintext highlighter-rouge">p</code> to arrive at an <code class="language-plaintext highlighter-rouge">(cf * p - 1) * p = kN</code> (i.e. 0 mod N).  Luckily, we can use a Lattice Basis Reduction technique developed by Don Coppersmith in his paper “Finding Small Solutions to Small Degree Polynomials” to solve for <code class="language-plaintext highlighter-rouge">p</code>.</p>

<p>The code to do this is as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">5452318773620154613572502669913080727339917760196646730652258556145398937256752632887555812737783373177353194432136071770417979324393263857781686277601413222025718171529583036919918011865659343346014570936822522629937049429335236497295742667600448744568785484756006127827416640477334307947919462834229613581880109765730148235236895292544500644206990455843770003104212381715712438639535055758354549980537386992998458659247267900481624843632733660905364361623292713318244751154245275273626636275353542053068704371642619745495065026372136566314951936609049754720223393857083115230045986813313700617859091898623345607326632849260775745046701800076472162843326078037832455202509171395600120638911</span>
<span class="n">cf</span> <span class="o">=</span> <span class="mi">25895436290109491245101531425889639027975222438101136560069483392652360882638128551753089068088836092997653443539010850513513345731351755050869585867372758989503310550889044437562615852831901962404615732967948739458458871809980240507942550191679140865230350818204637158480970417486015745968144497190368319745738055768539323638032585508830680271618024843807412695197298088154193030964621282487334463994562290990124211491040392961841681386221639304429670174693151</span>

<span class="n">P</span><span class="p">.</span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">cf</span> <span class="o">*</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>

<span class="n">roots</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">monic</span><span class="p">().</span><span class="n">small_roots</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

<span class="c1"># [0, 166878663790065040663149504970052368124427462024107500159158464138407657299730521908976684364578086644682045134207945137293534705688910696520830729908263578233018529387676221035298300775812585471932551347478303730822844748034186479]
</span></code></pre></div></div>

<p>We see 2 results: 0 is a trivial root, so we can discard it, but we find out that the second value <code class="language-plaintext highlighter-rouge">166878663790065040663149504970052368124427462024107500159158464138407657299730521908976684364578086644682045134207945137293534705688910696520830729908263578233018529387676221035298300775812585471932551347478303730822844748034186479</code> divides N!</p>

<p>Thus, we have found <code class="language-plaintext highlighter-rouge">p</code>, and finding <code class="language-plaintext highlighter-rouge">q</code> is simply a matter of taking the square root of N / p.  We then proceed to calculate <code class="language-plaintext highlighter-rouge">phi = (p - 1) * q * (q - 1)</code> and  <code class="language-plaintext highlighter-rouge">d = e^-1 mod phi</code>.  However, the flag is padded with PKCS1<em>OAEP, so we have to PKCS1_OAEP unpad it to recover the original plaintext.  We ran into incorrect decryption errors when trying to use pycrypto’s PKCS1_OAEP, and since we were sure all our recovered parameters were correct, we switched to the _cryptography</em> module for the last part of the challenge.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">.</span><span class="n">construct</span><span class="p">((</span><span class="nb">long</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">long</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="nb">long</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>

<span class="n">final_key</span> <span class="o">=</span> <span class="n">load_pem_private_key</span><span class="p">(</span>
		<span class="n">key</span><span class="p">.</span><span class="n">exportKey</span><span class="p">(),</span>
		<span class="n">password</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
		<span class="n">backend</span><span class="o">=</span><span class="n">default_backend</span><span class="p">()</span>
		<span class="p">)</span>

<span class="n">flag</span> <span class="o">=</span> <span class="n">final_key</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span>
		<span class="n">c</span><span class="p">,</span>
		<span class="n">padding</span><span class="p">.</span><span class="n">OAEP</span><span class="p">(</span>
			<span class="n">mgf</span><span class="o">=</span><span class="n">padding</span><span class="p">.</span><span class="n">MGF1</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="n">hashes</span><span class="p">.</span><span class="n">SHA1</span><span class="p">()),</span>
			<span class="n">algorithm</span><span class="o">=</span><span class="n">hashes</span><span class="p">.</span><span class="n">SHA1</span><span class="p">(),</span>
			<span class="n">label</span><span class="o">=</span><span class="bp">None</span>
			<span class="p">)</span>
		<span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>

<p>Running this produces the flag <code class="language-plaintext highlighter-rouge">TWCTF{I_m_not_sad__I_m_happy_always}</code>.</p>

<p>The full code from start to finish can be found in solution.sage (install required libraries through <code class="language-plaintext highlighter-rouge">sage -pip install cryptography pycrypto</code> beforehand).</p>

<h2 id="flag">Flag</h2>

<p>TWCTF{I_m_not_sad__I_m_happy_always}</p>]]></content><author><name></name></author><category term="sample-posts" /><category term="formatting" /><category term="math" /><summary type="html"><![CDATA[Coppersmith's attack]]></summary></entry><entry><title type="html">ECC 2 (200) - PicoCTF 2017</title><link href="http://localhost:4000/about/blog/2017/happy-copy/" rel="alternate" type="text/html" title="ECC 2 (200) - PicoCTF 2017" /><published>2017-04-17T11:12:00-04:00</published><updated>2017-04-17T11:12:00-04:00</updated><id>http://localhost:4000/about/blog/2017/happy%20copy</id><content type="html" xml:base="http://localhost:4000/about/blog/2017/happy-copy/"><![CDATA[<p>ECC 2 was a 200 point challenge on PicoCTF 2017.</p>

<p>We are given the following handout:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Elliptic Curve: y^2 = x^3 + A*x + B mod M
M = 93556643250795678718734474880013829509320385402690660619699653921022012489089
A = 66001598144012865876674115570268990806314506711104521036747533612798434904785
B = *You can figure this out with the point below :)*

P = (56027910981442853390816693056740903416379421186644480759538594137486160388926, 65533262933617146434438829354623658858649726233622196512439589744498050226926)
n = *SECRET*
n*P = (61124499720410964164289905006830679547191538609778446060514645905829507254103, 2595146854028317060979753545310334521407008629091560515441729386088057610440)

n &lt; 400000000000000000000000000000

Find n.
</code></pre></div></div>

<p>Our first step will be to solve for \(b\) via rearranging the elliptic curve equation:</p>

\[y^2 = x^3 + ax + b\bmod n\]

\[b = y^2 - x^3 - ax\bmod n\]

<p>In Sage, this is done via substituting the \(x\) and \(y\) values as shown:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: x, y = P[0], P[1]
sage: b = (y^2 - x^3 - a*x) % N  #The ^ operator is exponentiation instead of XOR in Sage.
sage: print(b)
25255205054024371783896605039267101837972419055969636393425590261926131199030
</code></pre></div></div>

<p>Solving for \(b\), we obtain 25255205054024371783896605039267101837972419055969636393425590261926131199030.</p>

<p>We now have all the necessary parameters for the elliptic curve.  Thus, our next step is to define the curve over a finite field of integers modulo \(M\), and define the points \(P\) and \(Q\) to be on the curve:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F = FiniteField(M)
E = EllipticCurve(F,[A,B])
P = E.point(P)
Q = E.point(Q)
</code></pre></div></div>

<p>Essentially, this challenge requires us to solve the Elliptic Curve Discrete Logarithm Problem (ECDLP): compute the scalar \(n\) given the base point \(P\) and the product point \(Q\) where \(Q = nP\).  There are a few known attacks against ECDLP, including the:</p>
<ol>
  <li>MOV attack (involves finding linearly independent points and calculating Weil pairing to reduce ECDLP to over finite field instead of group of points on elliptic curve)</li>
  <li>Pohlig-Hellman (reduces discrete logarithm calculations to prime subgroups of the order of P and uses Chinese Remainder Theorem to solve system of congruences for discrete logarithm of the whole order )</li>
</ol>

<p>We can rule out the MOV attack, since it is infeasible given the size of the elliptic curve order. However, factoring the order of our elliptic curve \(E\) reveals many small prime factors, indicating that Pohlig-Hellman could be feasible:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: factor(E.order())
2^2 * 3 * 5 * 7 * 137 * 593 * 24337 * 25589 * 3637793 * 5733569 * 106831998530025000830453 * 1975901744727669147699767  
</code></pre></div></div>

<p>The goal of Pohlig-Hellman and the mathematics leading to it is as follows:</p>

<p>We are attempting to recreate a system of congruences to solve for the value of \(l\) (referred to as \(n\) in this problem):</p>

\[l \equiv l_1\pmod{p_1^{e_1}}\]

\[l \equiv l_2\pmod{p_2^{e_2}}\]

\[\ldots\]

\[l \equiv l_i\pmod{p_i^{e_i}}\]

<p>where \(l\) denotes the discrete logarithm for the order of \(P\), \(l_i\) denotes discrete logarithm calculations for each of the smaller prime orders (factors) \(p\) of \(P\), and \(e_i\) denotes the exponent of \(p\).</p>

<p>First, define an integer \(x\) such that \(x = p_1^{e_1}p_2^{e_2}...p_{r}^{e_r}\)  (in other words, \(x\) is equivalent to the order of \(P\)).</p>

<p>\(l_i\) can be written in the form:</p>

<p>\(l_i = z_0 + z_1\,p + z_2\,p_2 + ... + z_{e−1}p-1^{e-1}\\\)
where \(z \in [0,\,p-1]\).</p>

<p>We then define the points \(P_i = \frac{x}{p_i}P\), and \(Q_i = \frac{x}{p_i}Q\).</p>

<p>Since we know that the order of \(P_i\) is \(p_i\), we can rewrite the equation as \(Q_i = lP_i = z_iP_i\), we can now solve for every \(z_0...z_{e-1}\) by finding a value for \(z_i\) such that \(Q_i = z_i*P_i\).</p>

<p>This is comparable to brute force in that if the value of \(p\) is small enough, it is feasible to try all the values of \(z\) in range of \(e\) until a value which satisfies the equation above is found.</p>

<p>In Sage, this can be done as follows:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sage</span><span class="p">:</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">593</span><span class="p">,</span> <span class="mi">24337</span><span class="p">,</span> <span class="mi">25589</span><span class="p">,</span> <span class="mi">3637793</span><span class="p">,</span> <span class="mi">5733569</span><span class="p">,</span> <span class="mi">106831998530025000830453</span><span class="p">,</span> <span class="mi">1975901744727669147699767</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">dlogs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">sage</span><span class="p">:</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
          <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">order</span><span class="p">())</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span>
          <span class="n">dlog</span> <span class="o">=</span> <span class="n">discrete_log</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">t</span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="n">operation</span><span class="o">=</span><span class="s">"+"</span><span class="p">)</span>
          <span class="n">dlogs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dlog</span><span class="p">]</span>
          <span class="k">print</span><span class="p">(</span><span class="s">"factor: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span><span class="o">+</span><span class="s">", Discrete Log: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dlog</span><span class="p">))</span> <span class="c1">#calculates discrete logarithm for each prime order
</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">137</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">129</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">593</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">224</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">24337</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">5729</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">25589</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">13993</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">3637793</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">1730599</span>
<span class="n">factor</span><span class="p">:</span> <span class="mi">5733569</span><span class="p">,</span> <span class="n">dlog</span><span class="p">:</span> <span class="mi">4590572</span>

</code></pre></div></div>
<p>You will notice that Sage hangs while computing the discrete logarithms for last 2 prime factors.  However, we don’t need to know them, since in the problem statement, \(l\) was defined to be less than 400000000000000000000000000000.  Multiplying every prime order save for the last 2 returns a boundary of 443208349730265573969192476820, meaning that \(l\) fits within the bound!</p>

<p>Our final step is just to solve for \(l\) via CRT:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: l = crt(dlogs.primes[:-2])
152977126447386808276536247114
</code></pre></div></div>
<p>which returns the value for \(l\)!</p>

<p>Just to check the validity of \(l\), we perform a quick boolean comparison;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sage: l * P == Q
True
</code></pre></div></div>

<p>Thus, our value of \(l\) is indeed correct!</p>

<h3 id="flag">Flag</h3>

<p>152977126447386808276536247114</p>

<p>Note: due to random problem generation, your value may be different.</p>

<h3 id="full-code">Full code</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="mi">93556643250795678718734474880013829509320385402690660619699653921022012489089</span>
<span class="n">A</span> <span class="o">=</span> <span class="mi">66001598144012865876674115570268990806314506711104521036747533612798434904785</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">25255205054024371783896605039267101837972419055969636393425590261926131199030</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">56027910981442853390816693056740903416379421186644480759538594137486160388926</span><span class="p">,</span> <span class="mi">65533262933617146434438829354623658858649726233622196512439589744498050226926</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">61124499720410964164289905006830679547191538609778446060514645905829507254103</span><span class="p">,</span> <span class="mi">2595146854028317060979753545310334521407008629091560515441729386088057610440</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">FiniteField</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">E</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">E</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">factors</span><span class="p">,</span> <span class="n">exponents</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">factor</span><span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">order</span><span class="p">()))</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">exponents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">))][:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="n">dlogs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">order</span><span class="p">())</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span>
    <span class="n">dlog</span> <span class="o">=</span> <span class="n">discrete_log</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">t</span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="n">operation</span><span class="o">=</span><span class="s">"+"</span><span class="p">)</span>
    <span class="n">dlogs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dlog</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"factor: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span><span class="o">+</span><span class="s">", Discrete Log: "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">dlog</span><span class="p">))</span> <span class="c1">#calculates discrete logarithm for each prime order
</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">crt</span><span class="p">(</span><span class="n">dlogs</span><span class="p">,</span><span class="n">primes</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="http://wstein.org/edu/2010/414/projects/novotney.pdf">http://wstein.org/edu/2010/414/projects/novotney.pdf</a></li>
  <li><a href="https://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Sommerseth+Hoeiland.pdf">https://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Sommerseth+Hoeiland.pdf</a></li>
</ul>]]></content><author><name></name></author><category term="sample-posts" /><category term="cryptography" /><category term="math" /><summary type="html"><![CDATA[Pohlig-Hellman]]></summary></entry></feed>